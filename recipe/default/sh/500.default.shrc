# =====
# shell
# =====
export LC_ALL=C
export LANG=en_US.UTF-8
export EDITOR=vim

addpath $HOME/.local/bin /usr/local/bin /usr/local/sbin /usr/bin /bin /usr/sbin /sbin

if [ -n "$XDG_DATA_HOME" ]; then
  export LESSHISTFILE="${XDG_DATA_HOME}/less/history"
  export LESSKEY="${XDG_DATA_HOME}/less/keys"
fi

# =====
# asdf
# =====
if [ -n "$XDG_CONFIG_HOME" ]; then
  export ASDF_CONFIG_FILE="$XDG_CONFIG_HOME/asdf/config"
fi
if [ -n "$XDG_DATA_HOME" ]; then
  export ASDF_DATA_DIR="$XDG_DATA_HOME/asdf"
fi

# =====
# gibo
# =====
if [ -n "$XDG_CACHE_HOME" ]; then
  export GIBO_BOILERPLATES="$XDG_CACHE_HOME/gibo"
fi


# =====
# fzf
# =====
if (which fzf &> /dev/null); then
  export FZF_DEFAULT_OPTS='--height 50% --border --reverse --bind ctrl-k:kill-line --bind ctrl-j:execute::'

  function fzf-file () {
    local selected
    selected=$(find . -maxdepth 20 | grep -v '/\.' | tail -n +2 | fzf)
    if [ -n "$selected" ]; then
      BUFFER="${BUFFER}${selected}"
      CURSOR=$#BUFFER
    fi
    zle reset-prompt
  }

  function fzf-src() {
    local selected
    selected=$(ghq list --full-path | sed -e "s|${HOME}|~|" | fzf)
    if [ -n "$selected" ]; then
      BUFFER="${BUFFER}${selected}"
      CURSOR=$#BUFFER
    fi
    zle reset-prompt
  }

  function fzf-gitlog () {
    if [[ ! "$BUFFER" =~ "\s*(git|tig)" ]]; then
      return
    fi

    local selected
    selected=$(git log --oneline | fzf | awk '{ print $1 }')
    if [ -n "$selected" ]; then
      BUFFER="${BUFFER}${selected}"
      CURSOR=$#BUFFER
    fi
    zle reset-prompt
  }

  function fzf-branch () {
    if [[ ! "$BUFFER" =~ "\s*(git|tig)" ]]; then
      return
    fi

    local selected
    selected=$(git branch -vv | fzf | awk '$0 = substr($0, 3) { print $1 }')
    if [ -n "$selected" ]; then
      BUFFER="${BUFFER}${selected}"
      CURSOR=$#BUFFER
    fi
    zle reset-prompt
  }

  function fzf-history() {
    local tac
    if which tac &> /dev/null; then
      tac="tac"
    else
      tac="tail -r"
    fi
  
    local selected
    selected=$(history 1 | eval $tac | fzf  --query "$LBUFFER" | awk '{$1=""; print $0}' | xargs)
    if [ -n "$selected" ]; then
      BUFFER="${BUFFER}${selected}"
      CURSOR=$#BUFFER
    fi
    zle reset-prompt
  }
fi


# =====
# Python
# =====
export PYTHONDONTWRITEBYTECODE=1
export PIPENV_VENV_IN_PROJECT=true

if [ -n "$XDG_CONFIG_HOME" ]; then
  export IPYTHONDIR="$XDG_CONFIG_HOME/ipython"
fi

# =====
# Ruby / Gem
# =====
if [ -n "$XDG_CACHE_HOME" ]; then
  export GEM_SPEC_CACHE="$XDG_CACHE_HOME/gem"
fi

# =====
# Ruby / Bundler
# =====
if [ -n "$XDG_CACHE_HOME" ]; then
  export BUNDLE_USER_CACHE="$XDG_CACHE_HOME/bundle"
fi
if [ -n "$XDG_CONFIG_HOME" ]; then
  export BUNDLE_USER_CONFIG="$XDG_CONFIG_HOME/bundle/config"
fi
if [ -n "$XDG_DATA_HOME" ]; then
  export BUNDLE_USER_PLUGIN="$XDG_DATA_HOME/bundle/plugin"
fi

# =====
# Node.js
# =====
if [ -n "$XDG_DATA_HOME" ]; then
  export NODE_REPL_HISTORY="$XDG_DATA_HOME/node/history"
fi

# =====
# Node.js / npm
# =====
if [ -n "$XDG_CONFIG_HOME" ]; then
  export NPM_CONFIG_USERCONFIG="$XDG_CONFIG_HOME/npm/config"
fi
if [ -n "$XDG_CACHE_HOME" ]; then
  export NPM_CONFIG_CACHE="$XDG_CACHE_HOME/npm"
fi
if [ -n "$XDG_RUNTIME_DIR" ]; then
  export NPM_CONFIG_TMP="$XDG_RUNTIME_DIR/npm"
fi

# Following codes are generated by the command `npm completion`.
if type complete &>/dev/null; then
  _npm_completion () {
    local words cword
    if type _get_comp_words_by_ref &>/dev/null; then
      _get_comp_words_by_ref -n = -n @ -n : -w words -i cword
    else
      cword="$COMP_CWORD"
      words=("${COMP_WORDS[@]}")
    fi

    local si="$IFS"
    if ! IFS=$'\n' COMPREPLY=($(COMP_CWORD="$cword" \
                           COMP_LINE="$COMP_LINE" \
                           COMP_POINT="$COMP_POINT" \
                           npm completion -- "${words[@]}" \
                           2>/dev/null)); then
      local ret=$?
      IFS="$si"
      return $ret
    fi
    IFS="$si"
    if type __ltrim_colon_completions &>/dev/null; then
      __ltrim_colon_completions "${words[cword]}"
    fi
  }
  complete -o default -F _npm_completion npm
elif type compdef &>/dev/null; then
  _npm_completion() {
    local si=$IFS
    compadd -- $(COMP_CWORD=$((CURRENT-1)) \
                 COMP_LINE=$BUFFER \
                 COMP_POINT=0 \
                 npm completion -- "${words[@]}" \
                 2>/dev/null)
    IFS=$si
  }
  compdef _npm_completion npm
elif type compctl &>/dev/null; then
  _npm_completion () {
    local cword line point words si
    read -Ac words
    read -cn cword
    let cword-=1
    read -l line
    read -ln point
    si="$IFS"
    if ! IFS=$'\n' reply=($(COMP_CWORD="$cword" \
                       COMP_LINE="$line" \
                       COMP_POINT="$point" \
                       npm completion -- "${words[@]}" \
                       2>/dev/null)); then

      local ret=$?
      IFS="$si"
      return $ret
    fi
    IFS="$si"
  }
  compctl -K _npm_completion npm
fi

# =====
# Dart / Flutter
# =====
if [ -n "$XDG_CACHE_HOME" ]; then
  export PUB_CACHE="$XDG_CACHE_HOME/pub"

  if [ -d $PUB_CACHE/bin ]; then
    addpath $PUB_CACHE/bin
  fi
fi

# =====
# Rust
# =====
if [ -n "$XDG_CACHE_HOME" ]; then
  export CARGO_HOME="$XDG_CACHE_HOME/cargo"

  if [ -d $CARGO_HOME/bin ]; then
    addpath $CARGO_HOME/bin
  fi
fi

# ===
# Gradle
# ===
if [ -n "$XDG_DATA_HOME" ]; then
  export GRADLE_USER_HOME="$XDG_DATA_HOME/gradle"
fi

# =====
# MySQL
# =====
if [ -n "$XDG_DATA_HOME" ]; then
  export MYSQL_HISTFILE="$XDG_DATA_HOME/mysql/history"
fi

# vim: ft=sh sw=2 ts=2 sts=2
